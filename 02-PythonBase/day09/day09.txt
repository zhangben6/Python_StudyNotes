day08回顾:
  两个容器类
      集合 set, 固定集合frozenset
    集合的创建
      set()
      set(可迭代对象)
      {1, 2, 3, 4}
      集合推导式: {表达式 for 变量列表 in 可迭代对象 if ...}
    固定集合的创建
      frozenset()
      frozenset(可迭代对象)
    集合的特点:
      无序, 不可重复,只能存放不可变对象
    集合的运算:
      &   |   -   ^   <   >   <= >= == !=
      in, not in, is, is not(判断的是id)
    
    集合方法:
      S.add(x)  添加:
      S.remove(x)
      S.discard(x)
      S.clear()
      S.pop()

两条语句
    def 语句
      创建一个函数,用函数变量来绑定函数,目的是以后可
      以重复调用

    return 语句
       语法:
          return 表达式


day09笔记:
  函数的传参(把数据给函数)
  函数的形参(接收函数调用传过来的数据)

python 函数的参数传递
  传递方式:
    1. 位置传参
        1.1 序列传参
    2. 关键字传参
        2.1 字典关键字传参

位置传参:
  实际参数(实参) 的对应关系与形式参数(形参)的对应关系是
  按位置来依次对应的.
  示例见:
    position_give_args.py
  说明:
    实参和形参通过位置进行传递和匹配
    实参的个数必须与形参的个数相同

序列传参
  序列传参是指在函数调用过程中,用*(星号) 将序列拆解后
  按位置进行传递的传参方式

  说明:
    序列传参时,序列拆解的位置将与形参一一对应
  示例见:
    sequence_give_args.py

关键字传参:
  关键字传参是指传参时,按着形参名称给形参赋值
  实参和形参按名称进行匹配

  说明:
    可以不按位置进行匹配
  示例见:
    keywords_give_args.py
   
字典关键字传参:
  是指实参为字典,将字典用** 拆解后进行关键字传参的传
  递方式
  
  说明:
    字典的键名和形参名必须一致
    字典的键名必须为符合标识符命名规则的字符串
    字典的键名要在形参中存在
  示例见:
    dict_keyword_give_args.py


函数的综合传参
  1. 函数的传参方式在能确定形参能唯一匹配到相应实参的情
     况下可以任意组合
  2. 函数的位置传参要先于关键字传参

  示例:
    def myfun(a, b, c):
        pass
    myfun(100, *[200, 300])
    myfun(100, *"BC")
    myfun(*"AB", 300)
    myfun(*[100], 200, *[300])
    myfun(100, c=300,b=200)
    位置传参前面不能有关键字传参
    myfun(a=100, 200, c=300)  # 错误的

    myfun(100, **{'c':300, 'b':200})
    myfun(100, **{'c':300}, b=200)
    myfun(100, b=200, **{'c':300})

练习:
  写一个函数minmax,传入三个参数,返回这三个参数中的最大值和最
  小值元素,结果要求,形成元组最小值在前,最大值在后返回
  给调用者
   如:
      def minmax(a, b, c):
          ....

    调用结果如下:
      t = minmax(300, 100, 200)
      print(t)  # (100, 300)


-------- 以下讲的内容是函数的形参-------
函数的缺省参数
  语法:
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2,
              形参名3=默认实参3, .....)
  作用:
    让函数的调用者少传递参数来调用函数
    缺省形参的作用是让函数调用少传入实参
  示例见:
    default_args.py
  说明:
    1. 缺省参数必须自右至左依次存在,如果一个参数有缺省
    参数, 则其右侧的所有参数都必须有缺省参数
    2. 缺省参数可以有0个,1个或多个,甚至全部都有缺省参数
  如:
    def fn(a, b=10, c): # 错误
        pass
    def fn(a=0, b=None, c=False):  # 是这对的
        pass

练习:
  写一个函数,myadd,此函数可以传入二个,三个或四个实参
    此函数功能是计算所有实参的和
  如:
    def myadd(...):
        ....

    print(myadd(100, 200, 300))  # 600
    print(myadd(1, 2, 3, 4))  # 10

函数的可变实参和不可变实参的传递
  示例见:
    variable_args.py
    variable_args2.py
  说明:
    当一个可变对象通过函数实参传入函数内时,在函数内
    可以通过局部变量来操作可变对象(列表,字典,集合...)

面试题:
  试运行以下程序的结果是什么, 为什么?
  L = [1, 2]

  def fn(a, lst=[]):
      lst.append(a)
      print(lst)

  fn(3, L)  # [1, 2, 3]
  fn(4, L)  # [1, 2, 3, 4]
  fn(5)  # [5]
  fn(6)  # [5, 6]
  fn(7)  # [5, 6, 7]


函数形参的定义方式
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参

位置形参:
  语法:
    def 函数名(形参变量1, 形参变量2, ....):
        语句块

星号元组形参
  语法:
    def 函数名(*元组形参名):
        语句块
  作用:
    收集多余的位置传参
  说明:
    元组形参名一般命名为'args'
    *元组形参一个函数只能有一个
  示例见:
    star_tuple_args.py

练习:
  写一个程序，mysum 可以传入任意个实参的参数，
  此函数的功能是返回所有实参的和
    def mysum(*args):
        ....
    print(mysum(1,2,3,4))  # 10
    print(mysum(1,2,3))  # 6


命名关键字形参
  语法
    def 函数名(*,命名关键字形参1, 命名关键字形参2,..):
        语句块
    或
    def 函数名(*args,命名关键字形参1, 命名关键字形参2,..):
        语句块

  作用:
    强制所有的命名关键字形参都必须用关键字传参或字典关
    键字传参
  示例见:
    named_keywords_args.py
  
思考:
  print()　函数的形参列表是如何定义的

练习:
  已知内建函数 max 的绑助文档为:
     max(...)
       max(iterable)---> value
       max(args1, arg2, *args)  --> value

    仿造max函数，写一个与max功能完全一样的mymax函数
    (要求: 不允许调用内键的max函数)
    如:
      def mymax(...):
          ...
      print(mymax([6, 8, 3, 5]))  # 8
      print(mymax(100, 200))  # 200
      print(mymax(1, 3, 5, 9, 7))  # 9
      print(mymax())   # 报错

双星号字典形参
  语法:
    def 函数名(**字典形参名):
        语句块
  作用:
    收集多余的关键字传参
  说明:
    字典形参名一般命名为'kwargs'
    一个函数内字典形参最多只有一个
  示例见:
    dict_kwargs.py


函数的形参说明:
  位置形参，缺省参数，星号元组形参，双星号字典形参可以混
  合使用

函数形参自左至右的定义顺序为:
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参
示例:
  def fn(a, b, *args, c, **kwargs):
      pass
  fn(1, 2, 3, 4, c=30, d=40, e=50)

函数的不定长参数:
  有两种:  星号元组形参，双星号字典形参
  用不定长参数可以接收任意的传参
  如:
    def fn(*args, **kwargs):
        print(args, kwargs)


全局变量和局部变量
  局部变量
    1. 定义在函数内部的变量称为局部变量(函数的形参也是
       局部变量)
    2. 局部变量只能在函数内部使用
    3. 局部变量在函数调用时才能创建，在函数调用之后会
       自动销毁
  全局变量
    1. 定义在函数外部,模块内部的变量称为全局变量
    2. 全局变量所有的函数都可以直接访问(但函数内部不能将
       其直接赋值)
  说明:
    函数内部赋值语句不会对全局变量造成影响

练习:
  1. 写一个函数 get_chinese_char_count(s),此函数的
   功能是给定一个字符串,返回这个字符串中中文字符的个数
   如:
    def get_chinese_char_count(s):
        ...
    s = input("请输入中文英混合的字符串:")
    print('您输入的中文个数是',
           get_chinese_char_count(s))
    注: 中文字符的编码在 0x4E00-0x9FA5 之间

 2. 写一个函数isprime(x) 判断x是否为素数.如果为素数
    返回True,否则返回False
    如:
      print(isprime(3))  # True
      print(isprime(4))  # False

 3. 写一个函数prime_m2n(m, n) 返回从m开始,到n结束
    范围内的全部素数的列表,并打印对应的列表 (不包含n)
    如:
      def prime_m2n(m, n):
           ...
      L = prime_m2n(10, 20)
      print(L)  # [11, 13, 17, 19]
 4. 写一个函数primes(n)  返回指定范围内的全部素数
    (不包含n)的列表,打印印这些素数的列表, 如:
      def primes(n):
          ...
      L = primes(10)
      print(L)  # [2, 3, 5, 7]
    1) 打印 100以内的素数
    2) 打印 200以内全部素数的和


 5. 写一个myrange函数,参数可以传1~3个,实际含义
    与range函数规则相同,此函数返回符合range函数规则
    的列表
    如:
      L = myrange(4)
      print(L)  # [0, 1, 2, 3]
      L = myrange(4, 6)
      print(L)  # [4, 5]
      L = myrange(1, 10, 3)
      print(L)  # [1, 4, 7]

def myrange(*args):
    L = []
    if len(args) == 1:
        for x in range(0,args):
            L.append(x)
    elif len(args) == 2:
        for x in 








